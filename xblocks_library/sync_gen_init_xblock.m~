%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%   Center for Astronomy Signal Processing and Electronics Research           %
%   http://casper.berkeley.edu                                                %      
%   Copyright (C) 2011     Hong Chen                                          %
%                                                                             %
%   This program is free software; you can redistribute it and/or modify      %
%   it under the terms of the GNU General Public License as published by      %
%   the Free Software Foundation; either version 2 of the License, or         %
%   (at your option) any later version.                                       %
%                                                                             %
%   This program is distributed in the hope that it will be useful,           %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of            %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             %
%   GNU General Public License for more details.                              %
%                                                                             %
%   You should have received a copy of the GNU General Public License along   %
%   with this program; if not, write to the Free Software Foundation, Inc.,   %
%   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function sync_gen_init_xblock(blk, varargin)

defaults = {
	'sim_acc_len', 6, ...
    'fft_size', 1024, ...
    'fft_simult_inputs', 16, ...
    'pfb_fir_taps', 1, ...
    'reorder_vec', [2,2,2], ...
    'scale', 1, ...
    'comp_latency', 2, ...
    'ext_sync_period', 'on', ...
    'ext_sync_pulse', 'on', ...
};

sim_acc_len = get_var('sim_acc_len', 'defaults', defaults, varargin{:});
fft_size = get_var('fft_size', 'defaults', defaults, varargin{:});
fft_simult_inputs = get_var('fft_simult_inputs', 'defaults', defaults, varargin{:});
pfb_fir_taps = get_var('pfb_fir_taps', 'defaults', defaults, varargin{:});
reorder_vec = get_var('reorder_vec', 'defaults', defaults, varargin{:});
scale = get_var('scale', 'defaults', defaults, varargin{:});
comp_latency = get_var('comp_latency', 'defaults', defaults, varargin{:});
ext_sync_period = get_var('ext_sync_period', 'defaults', defaults, varargin{:});
ext_sync_pulse = get_var('ext_sync_pulse', 'defaults', defaults, varargin{:});
ext_sync_pulse = strcmp(ext_sync_pulse, 'on');


%% diagram

if pfb_fir_taps < 1,
    errordlg('Sync Generator: pfb_fir length must be >= 1')
end

% Calculate the LCM( FFT reorder delays )
lcm_reorder = 1;
for i=1:length(reorder_vec),
    lcm_reorder = lcm(lcm_reorder, reorder_vec(i));
end

sim_sync_period = scale * sim_acc_len * pfb_fir_taps * fft_size * lcm_reorder / fft_simult_inputs;


%% outports
sync_out = xOutport('sync_out');

%% diagram

% block: untitled3/Subsystem/Counter3
counter_rst = xSignal;
Counter3_out1 = xSignal;
Counter3 = xBlock(struct('source', 'Counter', 'name', 'Counter3'), ...
                         struct('n_bits', 32, ...
                                'rst', 'on', ...
                                'explicit_period', 'off', ...
                                'use_rpm', 'on'), ...
                         {counter_rst}, ...
                         {Counter3_out1});

% block: untitled3/Subsystem/Relational
if ext_sync_pulse
    
else
    sync_period_const_out1 = xSignal;
    Relational = xBlock(struct('source', 'Relational', 'name', 'Relational'), ...
                               struct('latency', 2), ...
                               {sync_period_const_out1, Counter3_out1}, ...
                               {counter_rst});
end
% block: untitled3/Subsystem/posedge
posedge = xBlock(struct('source', 'casper_library_misc/posedge', 'name', 'posedge'), ...
                        [], ...
                        {Counter3_out1}, ...
                        {sync_out});

% block: untitled3/Subsystem/sync_period_const
sync_period_const = xBlock(struct('source', 'Constant', 'name', 'sync_period_const'), ...
                                  struct('const', 766, ...
                                         'n_bits', 32, ...
                                         'bin_pt', 0), ...
                                  {}, ...
                                  {sync_period_const_out1});

% block: untitled/sync_gen/Counter3
Logical1_out1 = xSignal;
Counter3_out1 = xSignal;
Counter3 = xBlock(struct('source', 'Counter', 'name', 'Counter3'), ...
                         struct('n_bits', 32, ...
                                'rst', 'on', ...
                                'explicit_period', 'off', ...
                                'use_rpm', 'on'), ...
                         {Logical1_out1}, ...
                         {Counter3_out1});
% 
% % block: untitled/sync_gen/Logical
% 
% 
% 
% 
% % block: untitled/sync_gen/Logical1
% Logical1 = xBlock(struct('source', 'Logical', 'name', 'Logical1'), ...
%                          struct('logical_function', 'OR', ...
%                                 'n_bits', 8, ...
%                                 'bin_pt', 2), ...
%                          {Relational_out1, posedge2_out1}, ...
%                          {Logical1_out1});
% 
% % block: untitled/sync_gen/Mux
% Relational1_out1 = xSignal;
% sync_period_const_out1 = xSignal;
% sync_period_out1 = xSignal;
% Mux_out1 = xSignal;
% Mux = xBlock(struct('source', 'Mux', 'name', 'Mux'), ...
%                     [], ...
%                     {Relational1_out1, sync_period_const_out1, sync_period}, ...
%                     {Mux_out1});
% 
% % block: untitled/sync_gen/Relational
% Relational = xBlock(struct('source', 'Relational', 'name', 'Relational'), ...
%                            struct('latency', comp_latency), ...
%                            {Mux_out1, Counter3_out1}, ...
%                            {Relational_out1});
% 
% % block: untitled/sync_gen/Relational1
% zero_out1 = xSignal;
% Relational1 = xBlock(struct('source', 'Relational', 'name', 'Relational1'), ...
%                             struct('mode', 'a!=b', ...
%                                    'latency', comp_latency), ...
%                             {zero_out1, sync_period}, ...
%                             {Relational1_out1});
% 
% % block: untitled/sync_gen/Slice2
% 
%                    
% % block: untitled/sync_gen/posedge1
% posedge1 = xBlock(struct('source', 'casper_library_misc/posedge', 'name', 'posedge1'), ...
%                          [], ...
%                          {Logical_out1}, ...
%                          {sync_out});
% 
% 
% 
% sync_period_const = xBlock(struct('source', 'Constant', 'name', 'sync_period_const'), ...
%                                   struct('const', sim_sync_period - comp_latency, ...
%                                          'n_bits', 32, ...
%                                          'bin_pt', 0), ...
%                                   {}, ...
%                                   {sync_period_const_out1});
% 
% % block: untitled/sync_gen/zero
% zero = xBlock(struct('source', 'Constant', 'name', 'zero'), ...
%                      struct('arith_type', 'Unsigned', ...
%                             'const', 0, ...
%                             'n_bits', 32, ...
%                             'bin_pt', 0, ...
%                             'explicit_period', 'on'), ...
%                      {}, ...
%                      {zero_out1});


if ~isempty(blk) && ~strcmp(blk(1), '/')
    % Remove stray wires and unused blocks
    clean_blocks(blk);

    % Display the simulation sync period under the block.
    fmtstr = sprintf('sim_sync_period=%d ',sim_sync_period);
    set_param(blk, 'AttributesFormatString', fmtstr);
end
end

