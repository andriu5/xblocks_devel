function downsample_init_xblock(blk, varargin)

defaults = {'dec_rate', 3, ...
    'explicit_clk_rate', 'on', ...
    'input_clk_rate', 1, ...
    'xilinx',0};   % default: 0, don't use the xilinx cic, this is just for the convenience of testing

dec_rate = get_var('dec_rate', 'defaults', defaults, varargin{:});
explicit_clk_rate = get_var('explicit_clk_rate', 'defaults', defaults, varargin{:}); % when this is off, infer clock rate from input, then input_clk_rate is pratically disabled
input_clk_rate = get_var('input_clk_rate', 'defaults', defaults, varargin{:});
xilinx = get_var('xilinx', 'defaults', defaults, varargin{:});


%% inports
inport = xInport('In');
sync_in = xInport('sync_in');

%% outports
outport = xOutport('Out');
sync_out = xOutport('sync_out');

%% diagram


if xilinx
    downsample = xBlock(struct('source','xbsIndex/Down Sample', 'name', 'xDownSample'), ...
                        struct('sample_ratio', dec_rate, ...
                        'sample_phase', 'Last Value of Frame  (most efficient)'), ...
                        {inport}, ...
                        {outport});
    sync_out.bind(sync_in);
    return 
end

% block: Constant
Constant_out = xSignal;
Constant = xBlock(struct('source', 'Constant', 'name', 'Constant'), ...
                         struct('const',0,...
                         'explicit_period', 'off'), ...
                         {}, ...
                         {Constant_out});
                     
                     
% block: Counter
Counter_out = xSignal;
if strcmp(explicit_clk_rate, 'on')
    Counter = xBlock(struct('source', 'Counter', 'name', 'Counter1'), ...
                             struct('cnt_type', 'Count Limited', ...
                                    'cnt_to', 0, ...
                                    'cnt_by_val', 1, ...
                                    'operation', 'Down', ...
                                    'n_bits', nextpow2(dec_rate), ...
                                    'bin_pt', 0, ...
                                    'rst','on',... % provide reset port tied to sync pulse
                                    'start_count', dec_rate-1,...
                                    'explicit_period', 'on', ...
                                    'period', input_clk_rate), ...
                             {sync_in}, ...
                             {Counter_out});
else
    Counter = xBlock(struct('source', 'Counter', 'name', 'Counter1'), ...
                             struct('cnt_type', 'Count Limited', ...
                                    'cnt_to', 0, ...
                                    'cnt_by_val', 1, ...
                                    'operation', 'Down', ...
                                    'n_bits', 18, ...
                                    'bin_pt', 0, ...
                                    'rst','on',... % provide reset port tied to sync pulse
                                    'start_count', dec_rate-1,...
                                    'explicit_period', 'off'), ...
                             {sync_in}, ...
                             {Counter_out});
end

% block: my_downsample/downsample_init_xblock/Register
Relational_out = xSignal;
Register = xBlock(struct('source', 'Register', 'name', 'Register'), ...
                         struct('en', 'on'), ...
                         {inport, Relational_out}, ...
                         {outport});

% block: my_downsample/downsample_init_xblock/Relational
Relational = xBlock(struct('source', 'Relational', 'name', 'Relational'), ...
                           [], ...
                           {Counter_out, Constant_out}, ...
                           {Relational_out});

                       
% block: sync delay
Sync_delay = xBlock(struct('source', 'Delay', 'name', 'sync_delay'), ...
    struct('latency',1), ...
    {sync_in}, ...
    {sync_out});



if ~isempty(blk) && ~strcmp(blk(1),'/')
    clean_blocks(blk);
end
end

